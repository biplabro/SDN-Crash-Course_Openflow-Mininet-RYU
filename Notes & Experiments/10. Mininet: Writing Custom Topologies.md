# Mininet: Writing Custom Topologies

In this segment we will demonstrate to setup [atom](https://github.com/atom/atom) editor for writing mininet scripts & create topologies from scratch. Other text editors like gedit, pluma, leafpad, notepad etc. can also be used for the same. Selecting atom since its wide range of [plugin](https://atom.io/packages) support that makes life esier while developing & managing the code. 

## 1. Mininet Properties

In order to develop custom topologies, we need to take some properties of mininet in consideration beforehand. They are listed below. All the resources on Mininet API is taken from the official github documentation page[1]. 

**Features:**

* Custom topologies: A single switch, larger Internet-like topologies, the Stanford backbone, a data center, or anything else

* Running real programs: anything that runs on Linux is available for you to run, from web servers to TCP window monitoring tools to Wireshark.

* Customizing packet forwarding: Mininet's switches are programmable using the OpenFlow protocol. Custom Software-Defined Network designs that run in Mininet can easily be transferred to hardware OpenFlow switches for line-rate packet forwarding.

* Share and replicate results: anyone with a computer can run your code once you've packaged it up.

* Ease of use: you can create and run Mininet experiments by writing simple (or complex if necessary) Python scripts.

**Limitations:**

* Running on a single system is convenient, but it imposes resource limits: if your server has 3 GHz of CPU and can switch about 10 Gbps of simulated traffic, those resources will need to be balanced and shared among your virtual hosts and switches.

* Mininet uses a single Linux kernel for all virtual hosts; this means that you can't run software that depends on BSD, Windows, or other operating system kernels. (Although you can attach VMs to Mininet.)

* Mininet won't write your OpenFlow controller for you; if you need custom routing or switching behavior, you will need to find or develop a controller with the features you require.

* By default Mininet network is isolated from your LAN and from the internet - this is usually a good thing! However, you may use the NAT object and/or the `--nat` option to connect your Mininet network to your LAN via Network Address Translation. You can also attach a real (or virtual) hardware interface to your Mininet network (see examples/hwintf.py for details.)

* By default all Mininet hosts share the host file system and PID space; this means that you may have to be careful if you are running daemons that require configuration in /etc, and you need to be careful that you don't kill the wrong processes by mistake. (Note the bind.py example demonstrates how to have per-host private directories.)

* Unlike a simulator, Mininet doesn't have a strong notion of virtual time; this means that timing measurements will be based on real time, and that faster-than-real-time results (e.g. 100 Gbps networks) cannot easily be emulated. 

## 2. Atom editor: Installation & Setup

**Download link:** grab a copy from [Official GitHub repo](https://github.com/atom/atom/releases/tag/v1.53.0).

**Installation:** If its a debian based distribution, a simple double click on the atom package will do the job. 

**Installing Plugins:** open `atom editor` > `Edit` > `Preferences` > from the left column in the settings menu select `+ Install` > input desired package names in the search fields[2]. A number of useful plugins are listed below[3]:

*Python Development*

`autocomplete-python` – autocompletion powered by Jedi

`linter-pylint` – lint python using pylint, automatically installs linter

*General Development*

`script` – run code in atom

*Productivity tools, completely optional*

`file-icons` – improved visual grepping

`minimap` – preview full source code

`minimap-find-and-replace` – integration with find and replace

`minimap-git-diff` – integration with git diff

`minimap-linter` – integration with linter

`minimap-selection` – show buffer’s selection on the minimap

`hyperclick` – Ctrl+click Go-to-Definition for autocomplete-python

The above software is a personal choice. Any other text editor software like gEdit, Pluma, Leafpad, Mousepad, sublime editor etc. can be used to write the mininet python scripts.

## 3. Understanding the Mininet API

Mininet's API is built at three primary levels:

 * Low-level API: The low-level API consists of the base node and link classes (such as `Host`, `Switch`, and `Link` and their subclasses) which can actually be instantiated individually and used to create a network, but it is a bit unwieldy.

 * Mid-level API: The mid-level API adds the `Mininet` object which serves as a container for nodes and links. It provides a number of methods (such as `addHost()`, `addSwitch()`, and `addLink()`) for adding nodes and links to a network, as well as network configuration, startup and shutdown (notably `start()` and `stop()`.)

 * High-level API: The high-level API adds a topology template abstraction, the `Topo` class, which provides the ability to create reusable, parametrized topology templates. These templates can be passed to the `mn` command (via the `--custom` option) and used from the command line.

It is valuable to understand each of the API levels. In general when you want to control nodes and switches directly, you use the low-level API. When you want to start or stop a network, you usually use the mid-level API (notably the `Mininet` class.) 

Things become interesting when you start thinking about creating full networks. Full networks can be created using any of the API levels (as seen in the examples), but usually you will want to pick either the mid-level API (e.g. `Mininet.add*()`) or the high-level API (`Topo.add*()`) to create your networks. 

Here are examples of creating networks using each API level:

#### Low-level API: nodes and links

```python
h1 = Host( 'h1' )                                                                                                     
h2 = Host( 'h2' )                                                                                                     
s1 = OVSSwitch( 's1', inNamespace=False )                                                                             
c0 = Controller( 'c0', inNamespace=False )                                                                            
Link( h1, s1 )                                                                                                        
Link( h2, s1 )                                                                                                        
h1.setIP( '10.1/8' )                                                                                                  
h2.setIP( '10.2/8' )                                                                                                  
c0.start()                                                                                                            
s1.start( [ c0 ] )                                                                                                    
print h1.cmd( 'ping -c1', h2.IP() )                                                                                   
s1.stop()                                                                                                             
c0.stop() 
```

#### Mid-level API: Network object

```python
net = Mininet()                                                                                                       
h1 = net.addHost( 'h1' )                                                                                              
h2 = net.addHost( 'h2' )                                                                                              
s1 = net.addSwitch( 's1' )
c0 = net.addController( 'c0' )                                                                                          
net.addLink( h1, s1 )                                                                                                 
net.addLink( h2, s1 )                                                                                                 
net.start()
print h1.cmd( 'ping -c1', h2.IP() )                                                                                   
CLI( net )                                                                                                            
net.stop()  
```

#### High-level API: Topology templates

```python
class SingleSwitchTopo( Topo ):                                                                                               
    "Single Switch Topology"                                                                                                  
    def build( self, count=1 ):                                                                                      
        hosts = [ self.addHost( 'h%d' % i )                                                                                   
                  for i in range( 1, count + 1 ) ]                                                                                
        s1 = self.addSwitch( 's1' )                                                                                           
        for h in hosts:                                                                                                       
            self.addLink( h, s1 )                                                                                             

net = Mininet( topo=SingleSwitchTopo( 3 ) )                                                                               
net.start()                                                                                                               
CLI( net )                                                                                                                
net.stop()   
```







### _References_

```
[1] https://github.com/mininet/mininet/wiki/Introduction-to-Mininet#apilevels
[2] https://www.youtube.com/watch?v=oCOhwHNP7Lc
[3] https://inside-openflow.com/2016/06/29/custom-mininet-topologies-and-introducing-atom/

[4] 
[5] 
[6] 
[7] 
[8] 
[9] 
[10] 
[11] 
```
